package malwareDisassembler

import (
	"fmt"
	"log"
	"os/exec"

	pefile "github.com/awsaba/pefile-go"
)

// Disassembler is a function that will take in a Portable Executable File and will return the Strings common
// to most malware samples for connection, locating, and exfiltrating data.
func Disassembler(pe *pefile.PEFile) {

	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")
	fmt.Print("......Let's find some bad stuff............................\n")
	fmt.Print("...........................................................\n")
	fmt.Println("                                           ,_---~~~~~----._         ")
	fmt.Println("                                    _,,_,*^____      _____``*g*\\*, ")
	fmt.Println("                                    \\ __\\ \\'     ^.  \\      \\ ^@q   f ")
	fmt.Println("                                    [  @f | @))    |  | @))   l  0 _\\  ")
	fmt.Println("                                     \\`\\   \\~____\\ __\\____\\   \\   ")
	fmt.Println("                                    |           _l__l_           I   ")
	fmt.Println("                                    }          [______]           I  ")
	fmt.Println("                                    ]            | | |            |  ")
	fmt.Println("                                    ]             ~ ~             |  ")
	fmt.Println("                                    |                             | ")
	fmt.Println("                                    | 							 |")
	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")

	fmt.Println(`[+] We are going \n
								 [+] to start printing out \n
								 [+] the DosHeader String `)
	fmt.Println(pe.DosHeader.String())

	fmt.Println(`[+] Moving on to the next portion of the File \n
								 [+] Now to start printing out \n
								 [+] the DosHeader Size `)
	fmt.Println(pe.DosHeader.Size)

	fmt.Println(`[+] Moving on to the next portion of the File \n
								 [+] Now to start printing out \n
								 [+] the NTHeader String `)
	fmt.Println(pe.NTHeader.String())

	fmt.Println(`[+] Moving on to the next portion of the File \n
								[+] Now to start printing out \n
								[+] the COFFFileHeader String `)
	fmt.Println(pe.COFFFileHeader.String())

	fmt.Println(`[+] Moving on to the next portion of the File \n
							 [+] Now to start printing out \n
							 [+] the Optional Headers `)

	fmt.Println(pe.OptionalHeader)

	fmt.Println(`[+] Moving on to the next portion of the File \n
								 [+] Now to start printing out \n
								 [+] the Optional Headers Data Directories `)
	for key, val := range pe.OptionalHeader.DataDirs {
		fmt.Println(`[+] Moving on to the next portion of the File \n
									 [+] Now to start printing out \n
									 [+] Key: `)
		fmt.Println(key)
		fmt.Println(`[+] Moving on to the next portion of the File \n
									 [+] Now to start printing out \n
									 [+] Value: `)
		fmt.Println(val)
	}

	for key, val := range pe.OptionalHeader.Flags {
		fmt.Println(`[+] Moving on to the next portion of the File \n
									 [+] Now to start printing out \n
									 [+] Key: `)
		fmt.Println(key)
		fmt.Println(`[+] Moving on to the next portion of the File \n
									 [+] Now to start printing out \n
									 [+] Value: `)
		fmt.Println(val)
	}

	fmt.Println(`[+] Moving on to the next portion of the File \n
							 [+] Now to start printing out \n
							 [+] the range of the Portable Executable Sections `)

	// Print out the Sections inside the file in question
	for _, s := range pe.Sections {
		fmt.Println("[+] Portable Executable Sectiong String: %s", s.String())
	}

	// Print ouf the ImportDescriptors

	// for _, val := range pe.ImportDescriptors {
	// fmt.Println(val)
	// for _, val2 := range val.Imports {
	// 	fmt.Println(val2)
	// }
	// }

	fmt.Println("\nDirectory_Entry_IMPORT")
	for _, entry := range pe.ImportDescriptors {
		fmt.Println(string(entry.Dll))
		for _, imp := range entry.Imports {
			var funcname string
			if len(imp.Name) == 0 {
				funcname = fmt.Sprintf("ordinal+%d", imp.Ordinal)
			} else {
				funcname = string(imp.Name)
			}
			fmt.Println("\t", funcname)
		}
	}

	if pe.ExportDirectory != nil {
		fmt.Println("\nDirectory_Entry_IMPORT")
		fmt.Println(pe.ExportDirectory)
		for _, entry := range pe.ExportDirectory.Exports {
			fmt.Printf("%d: %s:0x%x, forward: %s\n", entry.Ordinal, string(entry.Name), entry.Address, entry.Forwarder)
		}
	}

}

// StringsWrapper will take in a pointer to a PE File and will run the UNIX strings command on it to look for common words
func StringsWrapper(pe *pefile.PEFile) {

	// struct to hold the words, or a pointer to a connection to a DB
	// Counters, Percentages, any other useful metrics in tabular and exportable form

	fmt.Println("[+] Running strings command to look for generic string indicators")
	// cmd := exec.Command("strings", "--help", "|", "grep", "help")
	// cmd := exec.Command("strings", pe.Filename, "|", "grep", "DOWNLOAD")
	// cmd := exec.Command("strings", "malware_data_science/ch1/ircbot.exe", "|", "grep", "DOWNLOAD")
	cmd := exec.Command("strings", pe.Filename)
	stdoutStderr, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Println("[-] I made a mistake ")
		log.Fatal(err)
	}
	fmt.Printf("%s\n", stdoutStderr)

	// strings code end?
}
