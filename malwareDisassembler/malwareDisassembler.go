package gx0re

import (
	"fmt"
	"log"
	"os"
	"os/exec"

	pefile "github.com/awsaba/pefile-go"
)

// Disassembler is a function that will take in a Portable Executable File and will return the Strings common
// to most malware samples for connection, locating, and exfiltrating data.
func Disassembler(*pefile.PEFile) {

	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")
	fmt.Print("......Let's find some bad stuff............................\n")
	fmt.Print("...........................................................\n")
	fmt.Println("                                           ,_---~~~~~----._         ")
	fmt.Println("                                    _,,_,*^____      _____``*g*\\*, ")
	fmt.Println("                                    \\ __\\ \\'     ^.  \\      \\ ^@q   f ")
	fmt.Println("                                    [  @f | @))    |  | @))   l  0 _\\  ")
	fmt.Println("                                     \\`\\   \\~____\\ __\\____\\   \\   ")
	fmt.Println("                                    |           _l__l_           I   ")
	fmt.Println("                                    }          [______]           I  ")
	fmt.Println("                                    ]            | | |            |  ")
	fmt.Println("                                    ]             ~ ~             |  ")
	fmt.Println("                                    |                             | ")
	fmt.Println("                                    | 							 |")
	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")
	fmt.Print("...........................................................\n")

	fmt.Println(" Enter the name of the file you would like to analyze ")
	args := os.Args[1:]
	if len(args) == 0 {
		fmt.Println("[+] using the testing malware IRCBot.exe")
		pe, err := pefile.NewPEFile("malware_data_science/ch1/ircbot.exe")
		fmt.Println("[+] The File in question is: \n" + "[+] \t" + pe.Filename)

		for _, e := range pe.Errors {
			fmt.Println("[+] Parser warning: \n\t", e)
		}
		fmt.Println("[+] " + pe.Filename + " has been loaded successfully ")

		fmt.Println(`[+] We are going \n
								 [+] to start printing out \n
								 [+] the DosHeader String `)
		fmt.Println(pe.DosHeader.String())

		fmt.Println(`[+] Moving on to the next portion of the File \n
								 [+] Now to start printing out \n
								 [+] the DosHeader Size `)
		fmt.Println(pe.DosHeader.Size)

		fmt.Println(`[+] Moving on to the next portion of the File \n
								 [+] Now to start printing out \n
								 [+] the NTHeader String `)
		fmt.Println(pe.NTHeader.String())

		fmt.Println(`[+] Moving on to the next portion of the File \n
								[+] Now to start printing out \n
								[+] the COFFFileHeader String `)
		fmt.Println(pe.COFFFileHeader.String())

		fmt.Println(`[+] Moving on to the next portion of the File \n
							 [+] Now to start printing out \n
							 [+] the Optional Headers `)

		fmt.Println(pe.OptionalHeader)

		fmt.Println(`[+] Moving on to the next portion of the File \n
								 [+] Now to start printing out \n
								 [+] the Optional Headers Data Directories `)
		for key, val := range pe.OptionalHeader.DataDirs {
			fmt.Println(`[+] Moving on to the next portion of the File \n
									 [+] Now to start printing out \n
									 [+] Key: `)
			fmt.Println(key)
			fmt.Println(`[+] Moving on to the next portion of the File \n
									 [+] Now to start printing out \n
									 [+] Value: `)
			fmt.Println(val)
		}

		for key, val := range pe.OptionalHeader.Flags {
			fmt.Println(`[+] Moving on to the next portion of the File \n
									 [+] Now to start printing out \n
									 [+] Key: `)
			fmt.Println(key)
			fmt.Println(`[+] Moving on to the next portion of the File \n
									 [+] Now to start printing out \n
									 [+] Value: `)
			fmt.Println(val)
		}

		fmt.Println(`[+] Moving on to the next portion of the File \n
							 [+] Now to start printing out \n
							 [+] the range of the Portable Executable Sections `)

		// Print out the Sections inside the file in question
		for _, s := range pe.Sections {
			fmt.Println("[+] Portable Executable Sectiong String: %s", s.String())
		}

		// Print ouf the ImportDescriptors

		// for _, val := range pe.ImportDescriptors {
		// fmt.Println(val)
		// for _, val2 := range val.Imports {
		// 	fmt.Println(val2)
		// }
		// }

		fmt.Println("\nDirectory_Entry_IMPORT")
		for _, entry := range pe.ImportDescriptors {
			fmt.Println(string(entry.Dll))
			for _, imp := range entry.Imports {
				var funcname string
				if len(imp.Name) == 0 {
					funcname = fmt.Sprintf("ordinal+%d", imp.Ordinal)
				} else {
					funcname = string(imp.Name)
				}
				fmt.Println("\t", funcname)
			}
		}

		if pe.ExportDirectory != nil {
			fmt.Println("\nDirectory_Entry_IMPORT")
			fmt.Println(pe.ExportDirectory)
			for _, entry := range pe.ExportDirectory.Exports {
				fmt.Printf("%d: %s:0x%x, forward: %s\n", entry.Ordinal, string(entry.Name), entry.Address, entry.Forwarder)
			}
		}
		//The code Below will be for handling the errors after testing
		// fmt.Println("Please enter a piece of software to analyze \n")
		// os.Exit(-1)
		if err != nil {
			fmt.Println(" There was a problem with the file, revert to the python script")
			fmt.Println(err)
			fmt.Println("I dont know what's going on down here")
			os.Exit(2)
		}
	}

}

// StringsWrapper will take in a pointer to a PE File and will run the UNIX strings command on it to look for common words
func StringsWrapper(*pefile.PEFile) {

	// struct to hold the words, or a pointer to a connection to a DB
	// Counters, Percentages, any other useful metrics in tabular and exportable form
	args := os.Args[1:]
	if len(args) == 0 {
		fmt.Println("[+] using the testing malware IRCBot.exe")
		pe, err := pefile.NewPEFile("malware_data_science/ch1/ircbot.exe")
		fmt.Println("[+] The File in question is: \n" + "[+] \t" + pe.Filename)

		for _, e := range pe.Errors {
			fmt.Println("[+] Parser warning: \n\t", e)
		}
		fmt.Println("[+] " + pe.Filename + " has been loaded successfully ")

		fmt.Println("[+] The File in question is: \n" + "[+] \t" + pe.Filename)

		for _, e := range pe.Errors {
			fmt.Println("[+] Parser warning: \n\t", e)
		}
		fmt.Println("[+] " + pe.Filename + " has been loaded successfully ")

		fmt.Println("[+] Running strings command to look for generic string indicators")
		// cmd := exec.Command("strings", "--help", "|", "grep", "help")
		// cmd := exec.Command("strings", pe.Filename, "|", "grep", "DOWNLOAD")
		// cmd := exec.Command("strings", "malware_data_science/ch1/ircbot.exe", "|", "grep", "DOWNLOAD")
		cmd := exec.Command("strings", pe.Filename)
		stdoutStderr, err := cmd.CombinedOutput()
		if err != nil {
			fmt.Println("[-] I made a mistake ")
			log.Fatal(err)
		}
		fmt.Printf("%s\n", stdoutStderr)

		// strings code end?
	}
}
